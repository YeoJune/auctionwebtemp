const fs = require('fs').promises;
const path = require('path');
const { TranslateClient, TranslateTextCommand } = require("@aws-sdk/client-translate");

class AdvancedTranslator {
  constructor(region, cacheFilePath, expireDays = 5) {
    this.translate = new TranslateClient({ region });
    this.cacheFilePath = cacheFilePath;
    this.cache = {};
    this.expireDays = expireDays;
    this.lastCallTime = Date.now();
    this.callInterval = 50; // Minimum time between API calls in milliseconds
    this.maxRetries = 3; // Maximum number of retries for API calls
    this.retryDelay = 1000; // Delay between retries in milliseconds
  }

  async initialize() {
    try {
      const data = await fs.readFile(this.cacheFilePath, 'utf8');
      this.cache = JSON.parse(data);
    } catch (error) {
      if (error.code !== 'ENOENT') {
        console.error('Error loading translation cache:', error);
      }
      // If file doesn't exist, start with an empty cache
      this.cache = {};
    }

    // Load initial wordDictionary
    const wordDictionaryPath = path.join(__dirname, 'wordDictionary.json');
    try {
      const wordDictionaryData = await fs.readFile(wordDictionaryPath, 'utf8');
      const wordDictionary = JSON.parse(wordDictionaryData);
      for (const [key, value] of Object.entries(wordDictionary)) {
        if (!this.cache[key]) {
          this.cache[key] = { translation: value, lastUsed: new Date().toISOString() };
        }
      }
    } catch (error) {
      console.error('Error loading wordDictionary:', error);
    }
  }

  async saveCache() {
    try {
      await fs.writeFile(this.cacheFilePath, JSON.stringify(this.cache, null, 2));
    } catch (error) {
      console.error('Error saving translation cache:', error);
    }
  }

  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async rawTranslate(text, retries = 0) {
    const now = Date.now();
    if (now - this.lastCallTime < this.callInterval) {
      await this.delay(this.callInterval - (now - this.lastCallTime));
    }
    this.lastCallTime = Date.now();

    const params = {
      Text: text,
      SourceLanguageCode: 'ja',
      TargetLanguageCode: 'ko'
    };
    const command = new TranslateTextCommand(params);
    try {
      const result = await this.translate.send(command);
      return result.TranslatedText;
    } catch (error) {
      if (error.name === 'ThrottlingException' && retries < this.maxRetries) {
        console.log(`API call throttled. Retrying in ${this.retryDelay}ms...`);
        await this.delay(this.retryDelay);
        return this.rawTranslate(text, retries + 1);
      }
      console.error('Translation error:', error.message);
      return text;
    }
  }

  async wordTranslate(text) {
    const words = text.split(/\s+/);
    const translatedWords = [];
    for (const word of words) {
      const translatedWord = await this.translateWord(word);
      translatedWords.push(translatedWord);
    }
    return translatedWords.join(' ');
  }

  async translateWord(word) {
    // Check if the word or any substring is in the cache
    for (let i = word.length; i > 0; i--) {
      const subWord = word.substring(0, i);
      if (this.cache[subWord]) {
        this.cache[subWord].lastUsed = new Date().toISOString();
        return this.cache[subWord].translation + word.substring(i);
      }
    }

    // If not in cache, translate using API
    const translation = await this.rawTranslate(word);
    this.cache[word] = { translation, lastUsed: new Date().toISOString() };
    return translation;
  }

  async cleanupCache() {
    const now = new Date();
    for (const [word, data] of Object.entries(this.cache)) {
      const lastUsed = new Date(data.lastUsed);
      if ((now - lastUsed) / (1000 * 60 * 60 * 24) > this.expireDays) {
        delete this.cache[word];
      }
    }
  }
}

module.exports = AdvancedTranslator;